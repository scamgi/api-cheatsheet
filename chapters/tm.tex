\subsection{Complessità degli Automi}
\begin{itemize}
    \item \textbf{DFSA (Automa a Stati Finiti Deterministico)}
    \begin{itemize}
        \item Complessità Temporale: $T_A(n) = \Theta(n)$
        \item Complessità Spaziale: $S_A(n) = \Theta(1)$
    \end{itemize}

    \item \textbf{DPDA (Automa a Pila Deterministico)}
    \begin{itemize}
        \item Complessità Temporale: $T_A(n) = \Theta(n)$
        \item Complessità Spaziale: $\Theta(0) \le \Theta(S_A(n)) \le \Theta(n)$
    \end{itemize}

    \item \textbf{k-DTM (Macchina di Turing Deterministica a k-nastri)}
    \begin{itemize}
        \item Complessità Temporale: Nessun limite generale. Per calcolarla devi immaginare il funzionamento della macchina.
        \item Complessità Spaziale: $\Theta(S_M(n)) \le \Theta(T_M(n))$
    \end{itemize}

    \item \textbf{SDTM (Macchina di Turing Deterministica a nastro singolo)}
    \begin{itemize}
        \item Complessità Temporale: Nessun limite generale. Per calcolarla devi immaginare il funzionamento della macchina.
        \item Complessità Spaziale: $S_M(n) = \Omega(n)$, ciò significa che la complessità spaziale dev'essere almeno lineare, questo perché il nastro di input coincide con il nastro di memoria.
    \end{itemize}
\end{itemize}

\textbf{TIP}: per il calcolo della complessità spaziale, ricordati di considerare il caso peggiore. Il caso peggiore può anche essere per una stringa che non viene accettata, ovvero $x \notin L$.

\subsection{Contatori (Implementati su DTM)}
\begin{itemize}
    \item \textbf{Complessità Spaziale}: per contare fino a $m$, sono necessari $\Theta(\log m)$ simboli. Se $m$ dipende dalla lunghezza dell'input $n$, la complessità spaziale diventa $S_M(n) = \Theta(\log n)$.
    \item \textbf{Complessità Temporale} (per eseguire $n$ incrementi/decrementi):
    \begin{itemize}
        \item $T(n) = \Theta(n)$: se ad ogni modifica vengono visitate solo le cifre necessarie (userai questo in sede d'esame).
        \item $T(n) = \Theta(n \log n)$: se ad ogni modifica si visitano tutte le cifre del contatore.
    \end{itemize}
\end{itemize}

\textbf{NOTA BENE}: In una k-DTM il controllo tra due contatori è di complessità temporale: $\Theta(\log(n))$

\subsection{Gestione Input Separati ($x\$y$)}
Quando l'input contiene un separatore (es. $x\$y$), la strategia ottimale e la complessità dipendono drasticamente dal numero di nastri disponibili.

\begin{itemize}
    \item \textbf{k-nastri (Strategia dei Nastri Multipli - $\Theta(n)$)}
    \begin{itemize}
        \item \textbf{Idea:} Copiare le parti su nastri diversi per elaborarle in parallelo.
        \item \textbf{Procedimento:}
        \begin{enumerate}
            \item Leggi $x$ e copialo sul \textit{Nastro 1}.
            \item Ignora il separatore \$.
            \item Leggi $y$ e copialo sul \textit{Nastro 2}.
            \item Riavvolgi le testine e processa $x$ e $y$ contemporaneamente.
        \end{enumerate}
        \item \textbf{Vantaggio:} Evita il movimento a "zig-zag" (ping-pong) della testina, riducendo la complessità da quadratica a lineare.
    \end{itemize}

    \item \textbf{Nastro singolo (Strategia a Zig-Zag - $\Theta(n^2)$)}
    \begin{itemize}
        \item \textbf{Idea:} Utilizzare la tecnica della \textbf{marcatura}.
        \item \textbf{Procedimento:}
        \begin{enumerate}
            \item Leggi un carattere di $x$, memorizzalo nello stato interno e \textit{marcalo} (es. sovrascrivilo con un simbolo speciale).
            \item Scorri verso destra superando il separatore \$.
            \item Trova il carattere corrispondente in $y$, processalo e marcalo.
            \item Torna indietro (a sinistra) fino al primo carattere non marcato di $x$.
            \item Ripeti finché l'input non è consumato.
        \end{enumerate}
        \item \textbf{Svantaggio:} Richiede continui attraversamenti del nastro per ogni carattere processato (avanti e indietro).
    \end{itemize}
\end{itemize}
