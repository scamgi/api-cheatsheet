\subsubsection{Complessità Vettori (Array)}

\begin{tabular}{|l|c|c|}
\hline
 & \shortstack{Non Ordinato} & \shortstack{Ordinato} \\
\hline
SEARCH (A, x) & $\Theta(n)$ & $\Theta(\log n)$ \\
\hline
INSERT (A, x) & $\Theta(1)^{*}$ & $\Theta(n)$ \\
\hline
DELETE (A, x) & $\Theta(n)$ & $\Theta(n)$ \\
\hline
SUCCESSOR (A, x) & $\Theta(n)$ & $\Theta(1)$ \\
\hline
PREDECESSOR (A, x) & $\Theta(n)$ & $\Theta(1)$ \\
\hline
MINIMUM (A) & $\Theta(n)$ & $\Theta(1)$ \\
\hline
MAXIMUM (A) & $\Theta(n)$ & $\Theta(1)$ \\
\hline
\end{tabular}

\vspace{2mm}
\footnotesize{* L'inserimento in un vettore non ordinato ha complessità $\Theta(1)$ solo se avviene in coda (append). Se l'inserimento avviene in una posizione specifica, la complessità è $\Theta(n)$ a causa della necessità di spostare gli elementi successivi.}

\subsubsection{Complessità Matrici}

\begin{tabular}{|l|c|c|}
\hline
 & \shortstack{Non Ordinata} & \shortstack{Ordinata$^{**}$} \\
\hline
SEARCH (M, x) & $\Theta(n \cdot m)$ & $\Theta(n+m)$ \\
\hline
ACCESS (M, i, j) & $\Theta(1)$ & $\Theta(1)$ \\
\hline
\end{tabular}

\vspace{2mm}
\footnotesize{** Per matrice ordinata si intende una matrice $n \times m$ in cui gli elementi sono in ordine crescente lungo ogni riga e lungo ogni colonna. L'algoritmo di ricerca con complessità $\Theta(n+m)$ parte da un angolo (es. in alto a destra) e ad ogni passo elimina una riga o una colonna. Questo approccio è valido anche per matrici con ordinamento misto (crescente sulle righe, decrescente sulle colonne).}

\subsubsection{Complessità Liste Concatenate}

\begin{tabular}{|l|c|c|c|c|}
\hline
 & \shortstack{Unsorted, \\ Singly linked} & \shortstack{Sorted, \\ Singly linked} & \shortstack{Unsorted, \\ Doubly linked} & \shortstack{Sorted, \\ Doubly linked} \\
\hline
SEARCH (L,k) & $\Theta(n)$ & $\Theta(n)$ & $\Theta(n)$ & $\Theta(n)$ \\
\hline
INSERT (L,x) & $\Theta(1)$ & $\Theta(n)$ & $\Theta(1)$ & $\Theta(n)$ \\
\hline
DELETE (L,x) & $\Theta(n)$ & $\Theta(n)$ & $\Theta(1)$ & $\Theta(1)$ \\
\hline
SUCCESSOR (L,x) & $\Theta(n)$ & $\Theta(1)$ & $\Theta(n)$ & $\Theta(1)$ \\
\hline
PREDECESSOR (L,x) & $\Theta(n)$ & $\Theta(n)$ & $\Theta(n)$ & $\Theta(1)$ \\
\hline
MAXIMUM (L) & $\Theta(n)$ & $\Theta(n)$ & $\Theta(n)$ & $\Theta(n)$ \\
\hline
MINIMUM (L) & $\Theta(n)$ & $\Theta(1)$ & $\Theta(n)$ & $\Theta(1)$ \\
\hline
\end{tabular}

\subsubsection{Complessità Tabelle Hash}

\begin{tabular}{|l|c|}
\hline
\textbf{Operazione} & \textbf{Complessità (caso medio)} \\
\hline
SEARCH (T, k) & $\Theta(1+\alpha)$ \\
\hline
INSERT (T, x) & $\Theta(1+\alpha)$ \\
\hline
DELETE (T, x) & $\Theta(1+\alpha)$ \\
\hline
\end{tabular}

\vspace{2mm}
\footnotesize{La complessità media delle operazioni in una tabella hash dipende dal fattore di carico $\alpha = n/m$ (elementi/slot). I valori indicati si riferiscono a una tabella con risoluzione delle collisioni tramite concatenamento. Per l'inserimento e la cancellazione in liste non ordinate, la complessità può essere $\Theta(1)$. Nel caso peggiore, tutte le operazioni possono degradare a $\Theta(n)$.}

\subsubsection{Complessità Alberi Binari di Ricerca (BST)}

\begin{tabular}{|l|c|}
\hline
\textbf{Operazione} & \textbf{Complessità} \\
\hline
SEARCH (T, k) & $\Theta(h)$ \\
\hline
INSERT (T, z) & $\Theta(h)$ \\
\hline
DELETE (T, z) & $\Theta(h)$ \\
\hline
MINIMUM (T) & $\Theta(h)$ \\
\hline
MAXIMUM (T) & $\Theta(h)$ \\
\hline
SUCCESSOR (T, x) & $\Theta(h)$ \\
\hline
PREDECESSOR (T, x) & $\Theta(h)$ \\
\hline
\end{tabular}

\vspace{2mm}
\footnotesize{La complessità delle operazioni su un Albero Binario di Ricerca (BST) dipende dall'altezza $h$ dell'albero. Nel caso peggiore (albero sbilanciato, simile a una catena lineare), $h = \Theta(n)$. Se l'albero è bilanciato, $h = \Theta(\log n)$.}
